From 5b883b4d9ed8c828dc2372933c3f5f273c5c94a5 Mon Sep 17 00:00:00 2001
From: yixiangzhike <yixiangzhike007@163.com>
Date: Sat, 25 Apr 2020 13:26:28 +0800
Subject: [PATCH] cve-2019-14868

---
 src/cmd/ksh93/sh/arith.c | 174 +++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 145 insertions(+), 29 deletions(-)

diff --git a/src/cmd/ksh93/sh/arith.c b/src/cmd/ksh93/sh/arith.c
index b105942..5c09471 100644
--- a/src/cmd/ksh93/sh/arith.c
+++ b/src/cmd/ksh93/sh/arith.c
@@ -57,6 +57,54 @@ static Namval_t FunNode =
 	"?",
 };
 
+#ifndef M_1_PIl
+#define M_1_PIl 0.3183098861837906715377675267450287L
+#endif
+#ifndef M_2_PIl
+#define M_2_PIl 0.6366197723675813430755350534900574L
+#endif
+#ifndef M_2_SQRTPIl
+#define M_2_SQRTPIl 1.1283791670955125738961589031215452L
+#endif
+#ifndef M_El
+#define M_El 2.7182818284590452353602874713526625L
+#endif
+#ifndef M_LOG2El
+#define M_LOG2El 1.4426950408889634073599246810018921L
+#endif
+#ifndef M_LOG10El
+#define M_LOG10El 0.4342944819032518276511289189166051L
+#endif
+#ifndef M_LN2l
+#define M_LN2l 0.6931471805599453094172321214581766L
+#endif
+#ifndef M_LN10l
+#define M_LN10l 2.3025850929940456840179914546843642L
+#endif
+#ifndef M_PIl
+#define M_PIl 3.1415926535897932384626433832795029L
+#endif
+#ifndef M_PI_2l
+#define M_PI_2l 1.5707963267948966192313216916397514L
+#endif
+#ifndef M_PI_4l
+#define M_PI_4l 0.7853981633974483096156608458198757L
+#endif
+#ifndef M_SQRT2l
+#define M_SQRT2l 1.4142135623730950488016887242096981L
+#endif
+#ifndef M_SQRT1_2l
+#define M_SQRT1_2l 0.7071067811865475244008443621048490L
+#endif
+
+// The first three entries cann't be moved or it will break the code.
+static const struct Mathconst Mtable[] = {
+    {"1_PI", M_1_PIl}, {"2_PI", M_2_PIl},   {"2_SQRTPI", M_2_SQRTPIl},
+    {"E", M_El},       {"LOG2E", M_LOG2El}, {"LOG10E", M_LOG10El},
+    {"LN2", M_LN2l},   {"PI", M_PIl},       {"PI_2", M_PI_2l},
+    {"PI_4", M_PI_4l}, {"SQRT2", M_SQRT2l}, {"SQRT1_2", M_SQRT1_2l},
+    {"", 0.0}};
+
 static Namval_t *scope(register Namval_t *np,register struct lval *lvalue,int assign)
 {
 	register int flag = lvalue->flag;
@@ -217,6 +265,66 @@ int	sh_mathstd(const char *name)
 	return(sh_mathstdfun(name,strlen(name),NULL)!=0);
 }
 
+static_fn Sfdouble_t number(const char *s, char **p, int b, struct lval *lvalue) {
+    Sfdouble_t r;
+    char *t;
+    int oerrno;
+    int c;
+    char base;
+    struct lval v;
+
+    oerrno = errno;
+    errno = 0;
+    base = b;
+
+    if (!lvalue) {
+        lvalue = &v;
+    } else if (lvalue->shp->bltindata.bnode == SYSLET && !sh_isoption(lvalue->shp, SH_LETOCTAL)) {
+        while (*s == '0' && isdigit(s[1])) s++;
+    }
+    lvalue->eflag = 0;
+    lvalue->isfloat = 0;
+    r = strton64(s, &t, &base, -1);
+    if (*t == '8' || *t == '9') {
+        base = 10;
+        errno = 0;
+        r = strton64(s, &t, &base, -1);
+    }
+    if (base <= 1) base = 10;
+    if (*t == '_') {
+        if ((r == 1 || r == 2) && strcmp(t, "_PI") == 0) {
+            t += 3;
+            r = Mtable[(int)r - 1].value;
+        } else if (r == 2 && strcmp(t, "_SQRTPI") == 0) {
+            t += 7;
+            r = Mtable[2].value;
+        }
+    }
+    c = r == LLONG_MAX && errno ? 'e' : *t;
+    if (c == getdecimal() || c == 'e' || c == 'E' || (base == 16 && (c == 'p' || c == 'P'))) {
+        r = strtold(s, &t);
+        lvalue->isfloat = TYPE_LD;
+    }
+    if (t > s) {
+        if (*t == 'f' || *t == 'F') {
+            t++;
+            lvalue->isfloat = TYPE_F;
+            r = (float)r;
+        } else if (*t == 'l' || *t == 'L') {
+            t++;
+            lvalue->isfloat = TYPE_LD;
+        } else if (*t == 'd' || *t == 'D') {
+            t++;
+            lvalue->isfloat = TYPE_LD;
+            r = (double)r;
+        }
+    }
+    errno = oerrno;
+    *p = t;
+    return r;
+}
+
+
 static Sfdouble_t arith(const char **ptr, struct lval *lvalue, int type, Sfdouble_t n)
 {
 	Shell_t		*shp = lvalue->shp;
@@ -500,37 +608,45 @@ static Sfdouble_t arith(const char **ptr, struct lval *lvalue, int type, Sfdoubl
 	return(r);
 }
 
-/*
- * convert number defined by string to a Sfdouble_t
- * ptr is set to the last character processed
- * if mode>0, an error will be fatal with value <mode>
- */
-
+// Convert number defined by string to a Sfdouble_t.
+// Ptr is set to the last character processed.
+// If mode>0, an error will be fatal with value <mode>.
 Sfdouble_t sh_strnum(register const char *str, char** ptr, int mode)
 {
-	Shell_t	*shp = sh_getinterp();
-	register Sfdouble_t d;
-	char base=(shp->inarith?0:10), *last;
-	if(*str==0)
-	{
-		if(ptr)
-			*ptr = (char*)str;
-		return(0);
-	}
-	errno = 0;
-	d = strtonll(str,&last,&base,-1);
-	if(*last || errno)
-	{
-		if(!last || *last!='.' || last[1]!='.')
-			d = strval(shp,str,&last,arith,mode);
-		if(!ptr && *last && mode>0)
-			errormsg(SH_DICT,ERROR_exit(1),e_lexbadchar,*last,str);
-	}
-	else if (!d && *str=='-')
-		d = -0.0;
-	if(ptr)
-		*ptr = last;
-	return(d);
+    Shell_t	*shp = sh_getinterp();
+    register Sfdouble_t d;
+    char *last;
+
+    if (*str == 0) {
+        d = 0.0;
+        last = (char *)str;
+    } else {
+        d = number(str, &last, shp->inarith ? 0 : 10, NULL);
+        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {
+            // This call is to handle "base#value" literals if we're importing untrusted env vars.
+            d = number(str, &last, 0, NULL);
+        }
+        if (*last) {
+            if (sh_isstate(shp, SH_INIT)) {
+                // Initializing means importing untrusted env vars. Since the string does not appear
+                // to be a recognized numeric literal give up. We can't safely call strval() since
+                // that allows arbitrary expressions which would create a security vulnerability.
+                d = 0.0;
+            } else {
+                if (*last != '.' || last[1] != '.') {
+                    d = strval(shp, str, &last, arith, mode);
+                    Varsubscript = true;
+                }
+                if (!ptr && *last && mode > 0) {
+                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
+                }
+            }
+        } else if (d == 0.0 && *str == '-') {
+            d = -0.0;
+        }
+    }
+    if (ptr) *ptr = last;
+    return d;
 }
 
 Sfdouble_t sh_arith(Shell_t *shp,register const char *str)
-- 
1.8.3.1

